---
import type { ImageMetadata } from "astro";
import { Picture } from "astro:assets";

interface Props {
	src: string | { src: string };
	alt: string;
	title: string;
}

const { src, alt, title } = Astro.props;

// Extract the actual path
const normalizedSrc = typeof src === "object" && src.src ? src.src : src;

// Function to get the original filename without the hash
const getOriginalFilename = (path: string) => {
	// Remove query parameters
	const withoutQuery = path.split("?")[0];

	// If it's a transformed path (contains hash like .ZlVW-SV-.),
	// extract the original filename
	const hashMatch = withoutQuery.match(
		/([^/]+)\.[\w-]+\.(jpeg|jpg|png|gif|webp)$/
	);
	if (hashMatch) {
		return `${hashMatch[1]}.${hashMatch[2]}`;
	}

	// Handle regular paths
	const filename = withoutQuery.split("/").pop() || "";
	return filename;
};

// Clean up the path and get original filename
const originalFilename = getOriginalFilename(normalizedSrc);

// Import all images from the assets directory
const images = import.meta.glob<{ default: ImageMetadata }>(
	"/src/assets/images/**/*.{jpeg,jpg,png,gif,webp}"
);

// Find the matching image path by original filename
const imagePaths = Object.keys(images);
const matchingPath = imagePaths.find((path) => {
	const pathFilename = path.split("/").pop() || "";
	return pathFilename === originalFilename;
});

const hasMatchingImage = !!matchingPath;

if (!hasMatchingImage) {
	console.warn(`No matching original image found for: ${originalFilename}`);
	console.warn("Available images:", imagePaths);
}
---

<figure class="post-image grid">
	{
		hasMatchingImage ? (
			<Picture
				src={images[matchingPath]()}
				alt={alt}
				formats={["avif", "webp"]}
				widths={[640, 960, 1280, 1920]}
				sizes={`(max-width: 96rem) 100vw, 1328px`}
			/>
		) : (
			<img src={normalizedSrc} alt={alt} />
		)
	}
	{title && <figcaption>{title}</figcaption>}
</figure>
